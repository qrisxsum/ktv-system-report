# 聚合与口径计算设计文档 (Lite版)

## 文档说明

本文档基于《具体需求.md》和《简化.md》，制定 KTV 报表系统的**简化版**聚合与计算规范。

**核心理念**：放弃复杂的预计算宽表和物化视图，利用 **MySQL 8.0 索引** 和 **SQL 实时聚合** 满足报表查询需求（单日单店数据量小，实时聚合性能足够）。口径逻辑**代码化**（Python/SQL），而非**表结构化**。

**版本号**: v2.2 (Lite - Final Aligned)  
**生成日期**: 2025-12-09  
**技术栈**: MySQL 8.0, SQLAlchemy, Pandas

---

## 一、口径定义 (标准化)

### 1.1 实收金额 (Actual Amount)

**核心公式**：
`实收金额 = 销售金额 - (免单 + 挂账 + 折扣 + 抹零 + 调整)`
或者
`实收金额 = SUM(收入类支付方式)`

**处理策略**：
-   **存储层**：在事实表（`fact_booking` 等）入库时，直接计算并存储 `actual_amount` 字段。
-   **计算逻辑**：
    -   **收入类支付** (WeChat, Alipay, Cash, POS, etc.) -> **+**
    -   **权益类/成本类** (Member, Employee Credit, Gift, etc.) -> **0 (不计入)**
    -   在代码常量中维护 `INCOME_PAYMENT_TYPES` 列表，入库 `cleaner` 阶段自动计算。

### 1.2 业绩 (Performance)

-   **定义**：员工考核业绩。
-   **来源**：直接读取原始文件中的“基本业绩”列。
-   **聚合**：`SUM(base_performance)`。

### 1.3 毛利 (Profit)

-   **定义**：`利润 = 销售金额 - 成本`。
-   **来源**：酒水销售表中的对应字段。
-   **聚合**：`SUM(profit)`。

### 1.4 赠送 (Gift)

-   **定义**：赠送出去的商品数量和金额。
-   **来源**：酒水销售表中的 `gift_qty` 和 `gift_amount`。
-   **聚合**：`SUM(gift_qty)`, `SUM(gift_amount)`。

---

## 二、聚合策略 (Real-time SQL)

**简化决策**：
-   **移除**：`agg_daily_*` 物理宽表、MySQL Event 定时刷新任务。
-   **采用**：**按需实时查询**。
-   **理由**：KTV 每日数据量级（几百至几千行）在 MySQL 索引覆盖下，实时 `GROUP BY` 耗时通常 < 100ms。

### 2.1 通用聚合查询接口

前端传入查询参数，后端动态生成 SQL。

**输入参数**：
-   `date_range`: `[start_date, end_date]`
-   `store_id`: 可选
-   `group_by`: `['date', 'store', 'employee', 'room_type', ...]`
-   `granularity`: `day` | `week` | `month` (当 group_by='date' 时生效)
-   `metrics`: `['sales', 'actual', 'profit', ...]`

**SQL 模板示例**：

```sql
SELECT 
    -- 动态选择聚合粒度
    CASE 
        WHEN :granularity = 'month' THEN DATE_FORMAT(biz_date, '%Y-%m')
        WHEN :granularity = 'week' THEN DATE_FORMAT(biz_date, '%Y-%u')
        ELSE biz_date 
    END as dimension_key,
    
    SUM(sales_amount) as sales,
    SUM(actual_amount) as actual,
    COUNT(DISTINCT order_no) as orders
FROM {fact_table}
WHERE 
    biz_date BETWEEN :start AND :end
    AND store_id = :store_id
GROUP BY dimension_key
ORDER BY dimension_key DESC
```

### 2.2 核心业务场景 SQL

#### 2.2.1 预订业绩报表 (Booking Stats)
```sql
SELECT 
    biz_date,
    employee_id,
    SUM(booking_qty) as total_qty,
    SUM(actual_amount) as total_actual,
    SUM(base_performance) as total_perf,
    SUM(gift_amount) as total_gift_amt, -- 赠送金额统计
    SUM(discount_amount) as total_discount -- 折扣统计
FROM fact_booking
WHERE store_id = 1 AND biz_date >= '2025-01-01'
GROUP BY biz_date, employee_id
```

#### 2.2.2 门店营收日报 (Store Daily)
```sql
SELECT 
    store_id,
    SUM(actual_amount) as revenue,
    SUM(sales_amount) as gmv,
    SUM(credit_amount) as total_credit  -- 挂账统计
FROM fact_booking
WHERE biz_date = '2025-01-01'
GROUP BY store_id
```

#### 2.2.3 酒水利润与库存分析 (Product Sales & Gift)
```sql
SELECT 
    product_id,
    SUM(sales_qty) as sold_qty,
    SUM(gift_qty) as gift_qty,          -- 赠送数量
    SUM(profit) as total_profit,
    SUM(cost_total) as total_cost,      -- 总成本 (用于计算利润率)
    SUM(sales_amount) as total_sales
FROM fact_sales
WHERE store_id = 1
GROUP BY product_id
ORDER BY total_profit DESC
LIMIT 10
```
*注：前端可根据返回结果计算 `利润率 = total_profit / total_cost` 和 `赠送率 = gift_qty / (sold_qty + gift_qty)`*

---

## 三、TopN 与高级分析

### 3.1 TopN 查询
直接在 SQL 中使用 `ORDER BY` + `LIMIT`。

-   **Top 10 员工**: `ORDER BY total_actual DESC LIMIT 10`
-   **Top 10 畅销酒水**: `ORDER BY sold_qty DESC LIMIT 10`

### 3.2 趋势分析
前端请求时间范围数据，后端按日 `GROUP BY biz_date` 返回列表，前端 ECharts 渲染折线图。

---

## 四、校验报告生成 (On-the-fly)

**策略**：校验逻辑主要在**导入阶段**完成（生成静态报告存入 `meta_file_batch`），聚合阶段不再重复校验。

**报告内容**：
-   **平衡性**：`ABS(销售 - 扣减 - 实收) < 1.0`
-   **完整性**：关键维度（员工、包厢）是否缺失。

---

## 五、开发建议 (Python Service)

建议在 `app/services/stats_service.py` 中封装聚合逻辑：

```python
class StatsService:
    def query_sales_stats(self, start_date, end_date, store_id=None, granularity='day'):
        # 处理时间粒度
        date_col = FactSales.biz_date
        if granularity == 'month':
            date_col = func.date_format(FactSales.biz_date, '%Y-%m')
        
        query = select(
            date_col.label("date_key"),
            func.sum(FactSales.sales_qty).label("sold_qty"),
            # ...
        ).group_by(date_col)
        # ...
```

---

## 六、总结

简化版聚合设计移除了 ETL 中最重、最难维护的“宽表层”，回归到**关系型数据库最擅长**的 SQL 统计能力上。对于 KTV 这种数据规模（单日万级以下），这是性价比最高的选择。
