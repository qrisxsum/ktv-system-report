# 聚合与口径计算设计文档

## 文档说明

本文档基于《具体需求.md》《字段映射.md》和《入库模型.md》的要求，详细设计 KTV 多门店报表自动化系统的聚合与口径计算方案，包括口径函数定义、聚合策略、宽表/物化视图设计、校验报告生成等核心内容。

**版本号**: v1.0  
**生成日期**: 2025-12-03  
**数据库版本**: MySQL 5.7+（推荐 MySQL 8.0+）

---

## 一、目标与范围

### 1.1 核心目标

1. **产出宽表/物化视图**：支持日/周/月/自定义时间范围的聚合查询
2. **多维度聚合**：按门店、员工、包厢、商品等维度进行聚合分析
3. **TopN 查询**：支持按指标排序，获取 TopN 结果
4. **口径标准化**：统一实收、业绩、毛利等核心指标的计算口径
5. **校验报告**：生成平衡校验报告，确保数据准确性

### 1.2 业务需求

根据《具体需求.md》的要求：
- **汇总口径**：日/周/月/自定义范围，按门店、员工、包厢、商品多维聚合
- **指标看板**：收入、实收、折扣、赠送、业绩、毛利等核心指标
- **维度筛选**：支持按门店/时间/员工/包厢/商品等维度筛选
- **导出功能**：支持导出 CSV 格式的聚合结果

### 1.3 技术约束

- **数据库版本**：MySQL 5.7+（推荐 MySQL 8.0+，支持物化视图和窗口函数）
- **性能要求**：单日单店文件级别处理在分钟级；支持并行按文件/门店处理
- **数据量**：考虑分区表设计，按月分区，单分区不超过1000万行

---

## 二、口径定义与配置化

### 2.1 核心指标口径

#### 2.1.1 实收金额口径

**定义**：实收金额是实际收到的现金收入，需要剔除成本/权益类支付方式，避免重复计算。

**计算公式**（预订汇总表）：
```
实收金额 = 销售金额 
         - 免单金额 
         - 挂账金额 
         - 调整金额 
         - 折扣金额 
         - 抹零金额
         = 收入类支付方式合计
```

**计算公式**（包厢开台分析表）：
```
实收金额 = 账单合计 
         - 抹零金额 
         - 调整金额 
         - 挂账金额 
         - 免单金额 
         - 房费折扣金额 
         - 酒水折扣金额
         - 权益类支付方式合计
         = 收入类支付方式合计
```

**注意**：
- 赠送金额不参与实收金额计算（赠送金额已体现在销售金额/账单合计的构成中）
- 会员支付（含会员本金+会员赠送）属于权益类，不计入实收金额
- 会员支付需与会员本金+会员赠送去重，用于会员权益分析

#### 2.1.2 业绩口径

**定义**：业绩用于员工考核，基于"基本业绩"列。

**数据来源**：
- 预订汇总事实表：`base_performance` 字段
- 包厢开台事实表：`base_performance` 字段

**计算公式**：
```
业绩 = SUM(基本业绩)
```

**聚合维度**：
- 按员工聚合：`SUM(base_performance) GROUP BY employee_id, business_date`
- 按门店聚合：`SUM(base_performance) GROUP BY store_id, business_date`
- 按部门聚合：`SUM(base_performance) GROUP BY department, business_date`

#### 2.1.3 毛利口径

**定义**：毛利 = 销售金额 - 成本，用于商品盈利能力分析。

**数据来源**：酒水销售事实表

**计算公式**：
```
利润 = 销售金额小计 - 成本小计
成本小计 = 成本_销售 + 成本_赠送
利润率 = (利润 / 成本小计) × 100
```

**注意**：
- 销售金额为折后金额
- 成本包含销售成本和赠送成本
- 利润率 = 利润 / 成本小计 × 100（成本利润率）
- 利润率字段存储为百分比数值（如4700表示47%），使用时需除以100

### 2.2 支付方式分类配置化

#### 2.2.1 收入类支付方式（计入实收）

**预订汇总表收入类支付方式**：
- 微信支付 (`payment_wechat`)
- 支付宝 (`payment_alipay`)
- 现金 (`payment_cash`)
- POS机银行卡 (`payment_pos_card`)
- 服务员收款 (`payment_waiter`)
- 付呗 (`payment_fubei`)
- 团购 (`payment_groupon`)
- 抖音 (`payment_douyin`)
- POS机 (`payment_pos`)
- 高德 (`payment_gaode`)

**包厢开台分析表收入类支付方式**：
- 微信支付 (`payment_wechat`)
- 支付宝 (`payment_alipay`)
- 现金 (`payment_cash`)
- 银行卡 (`payment_bank_card`)
- 服务员收款 (`payment_waiter`)
- 付呗 (`payment_fubei`)
- 美团 (`payment_meituan`)
- 抖音 (`payment_douyin`)
- 扫码 (`payment_scan`)
- 高德 (`payment_gaode`)

**配置化设计**：
- 在 `meta_field_mapping` 表中，通过 `is_income_payment` 字段标识收入类支付方式
- 在 `dim_payment_method` 维度表中，通过 `is_income` 字段标识收入类支付方式
- 支持通过配置表动态调整支付方式分类

#### 2.2.2 成本/权益类支付方式（不计入实收）

**预订汇总表成本/权益类支付方式**：
- 会员支付 (`payment_member`) - 含会员本金+会员赠送
- 会员本金 (`payment_member_principal`) - 权益类
- 会员赠送 (`payment_member_gift`) - 权益类
- 员工信用扣款 (`payment_employee_credit`) - 成本类
- 店长签单 (`payment_manager_sign`) - 成本类
- 演绎提成 (`payment_performance_commission`) - 成本类
- 营销提成 (`payment_marketing_commission`) - 成本类
- 过期取酒 (`payment_expired_wine`) - 成本类
- 招待 (`payment_entertainment`) - 成本类
- 会员停用 (`payment_member_disabled`) - 成本类

**包厢开台分析表成本/权益类支付方式**：
- 会员支付 (`payment_member`) - 含会员本金+会员赠送
- 会员本金 (`payment_member_principal`) - 权益类
- 会员赠送 (`payment_member_gift`) - 权益类
- 员工信用扣款 (`payment_employee_credit`) - 成本类
- 店长签单 (`payment_manager_sign`) - 成本类
- 演绎提成 (`payment_performance_commission`) - 成本类
- 营销提成 (`payment_marketing_commission`) - 成本类
- 过期取酒 (`payment_expired_wine`) - 成本类
- 招待 (`payment_entertainment`) - 成本类
- 会员停用 (`payment_member_disabled`) - 成本类
- 三倍储值活动 (`payment_triple_recharge`) - 权益类（待确认是否计入实收）
- 定金消费 (`payment_deposit`) - 需确认口径

**配置化设计**：
- 在 `meta_field_mapping` 表中，通过 `is_cost_equity` 字段标识成本/权益类支付方式
- 在 `dim_payment_method` 维度表中，通过 `is_cost_equity` 字段标识成本/权益类支付方式
- 支持通过配置表动态调整支付方式分类

#### 2.2.3 待确认支付方式

**需要业务确认的支付方式**：
- 三倍充值活动/三倍储值活动 (`payment_triple_recharge`) - 需确认是否计入实收
- 往来款 (`payment_inter_account`) - 需确认口径
- 定金消费 (`payment_deposit`) - 需确认口径

**处理策略**：
- 在配置表中标记为"待确认"状态
- 默认不计入实收，但记录告警
- 待业务确认后更新配置

### 2.3 口径函数设计

#### 2.3.1 实收金额计算函数

**函数设计原则**：
- 配置化：从配置表读取收入类/成本权益类支付方式列表
- 可扩展：支持不同表类型的实收计算逻辑
- 可追溯：记录计算过程，便于审计

**函数签名**（伪代码）：
```
calculate_actual_received(
    table_type: str,  # 'booking_summary' | 'room_analysis'
    sales_amount: Decimal,  # 销售金额/账单合计
    deduction_fields: Dict[str, Decimal],  # 扣减项字典
    payment_fields: Dict[str, Decimal],  # 支付方式字典
    income_payment_list: List[str],  # 收入类支付方式列表（从配置读取）
    cost_equity_payment_list: List[str]  # 成本/权益类支付方式列表（从配置读取）
) -> Decimal
```

**计算逻辑**：
1. 方法一（扣减法）：实收 = 销售金额 - 所有扣减项 - 成本/权益类支付方式合计
2. 方法二（加总法）：实收 = 收入类支付方式合计
3. 两种方法结果应该一致，不一致时记录告警

#### 2.3.2 业绩计算函数

**函数签名**（伪代码）：
```
calculate_performance(
    table_type: str,  # 'booking_summary' | 'room_analysis'
    base_performance: Decimal  # 基本业绩字段
) -> Decimal
```

**计算逻辑**：
- 直接使用 `base_performance` 字段
- 聚合时使用 `SUM(base_performance)`

#### 2.3.3 毛利计算函数

**函数签名**（伪代码）：
```
calculate_profit(
    sales_amount_total: Decimal,  # 销售金额小计
    cost_total: Decimal  # 成本小计
) -> Tuple[Decimal, Decimal]  # (利润, 利润率)
```

**计算逻辑**：
```
利润 = 销售金额小计 - 成本小计
利润率 = (利润 / 成本小计) × 100  # 成本利润率
```

---

## 三、聚合策略设计

### 3.1 聚合粒度

#### 3.1.1 时间粒度

**支持的聚合粒度**：
- **日级聚合**：按营业日 (`business_date`) 聚合
- **周级聚合**：按周（使用 `dim_date.week`）聚合
- **月级聚合**：按月份（使用 `dim_date.month`）聚合
- **季度聚合**：按季度（使用 `dim_date.quarter`）聚合
- **年度聚合**：按年份（使用 `dim_date.year`）聚合
- **自定义范围**：按起止日期范围聚合

**时间维度关联**：
- 所有聚合查询都需要关联 `dim_date` 维度表
- 通过 `business_date` 关联，获取年、季度、月、周等时间属性

#### 3.1.2 业务粒度

**预订汇总事实表聚合粒度**：
- **员工维度**：按 `employee_id` + `business_date` 聚合
- **门店维度**：按 `store_id` + `business_date` 聚合
- **部门维度**：按 `department` + `business_date` 聚合
- **组合维度**：按 `store_id` + `employee_id` + `business_date` 聚合

**包厢开台事实表聚合粒度**：
- **包厢维度**：按 `room_id` + `business_date` 聚合
- **门店维度**：按 `store_id` + `business_date` 聚合
- **包厢类型维度**：按 `room_type` + `business_date` 聚合
- **区域维度**：按 `area_name` + `business_date` 聚合
- **组合维度**：按 `store_id` + `room_id` + `business_date` 聚合

**酒水销售事实表聚合粒度**：
- **商品维度**：按 `product_id` + `business_date` 聚合
- **门店维度**：按 `store_id` + `business_date` 聚合
- **商品类别维度**：按 `category_name` + `business_date` 聚合
- **区域维度**：按 `area` + `business_date` 聚合
- **组合维度**：按 `store_id` + `product_id` + `business_date` 聚合

### 3.2 聚合指标设计

#### 3.2.1 预订汇总聚合指标

**核心指标**：
- `total_booking_count`：订台数合计
- `total_sales_amount`：销售金额合计
- `total_actual_received`：实收金额合计
- `total_base_performance`：基本业绩合计
- `total_discount_amount`：折扣金额合计
- `total_gift_amount`：赠送金额合计
- `total_free_amount`：免单金额合计
- `total_credit_amount`：挂账金额合计

**支付方式指标**：
- `total_payment_wechat`：微信支付合计
- `total_payment_alipay`：支付宝合计
- `total_payment_cash`：现金合计
- `total_payment_member`：会员支付合计（权益类）
- `total_income_payments`：收入类支付方式合计
- `total_cost_equity_payments`：成本/权益类支付方式合计

**计算指标**：
- `discount_rate`：折扣率 = 折扣金额 / 销售金额 × 100
- `gift_rate`：赠送率 = 赠送金额 / 销售金额 × 100
- `actual_received_rate`：实收率 = 实收金额 / 销售金额 × 100

#### 3.2.2 包厢开台聚合指标

**核心指标**：
- `total_order_count`：开台单数合计（COUNT(DISTINCT order_no)）
- `total_bill_total`：账单合计金额合计
- `total_actual_received`：实收金额合计
- `total_base_performance`：基本业绩合计
- `total_duration_minutes`：消费时长合计（分钟）
- `avg_duration_minutes`：平均消费时长（分钟）
- `total_room_discount`：房费折扣金额合计
- `total_beverage_discount`：酒水折扣金额合计

**支付方式指标**：
- `total_payment_wechat`：微信支付合计
- `total_payment_alipay`：支付宝合计
- `total_payment_cash`：现金合计
- `total_payment_member`：会员支付合计（权益类）
- `total_income_payments`：收入类支付方式合计
- `total_cost_equity_payments`：成本/权益类支付方式合计

**计算指标**：
- `avg_bill_amount`：平均账单金额 = 账单合计 / 开台单数
- `avg_actual_received`：平均实收金额 = 实收金额 / 开台单数
- `room_utilization_rate`：包厢利用率 = 开台单数 / (包厢数 × 天数) × 100

#### 3.2.3 酒水销售聚合指标

**核心指标**：
- `total_sales_qty`：销售数量合计
- `total_sales_amount`：销售金额合计（折后）
- `total_cost_total`：成本小计合计
- `total_profit`：利润合计
- `total_gift_qty`：赠送数量合计
- `total_gift_amount`：赠送金额合计

**计算指标**：
- `avg_profit_rate`：平均利润率 = SUM(利润) / SUM(成本小计) × 100
- `weighted_profit_rate`：加权利润率 = SUM(利润) / SUM(成本小计) × 100
- `sales_amount_per_qty`：平均单价 = 销售金额合计 / 销售数量合计
- `gift_rate`：赠送率 = 赠送数量 / (销售数量 + 赠送数量) × 100

### 3.3 TopN 查询设计

#### 3.3.1 TopN 场景

**预订汇总 TopN**：
- TopN 员工（按实收金额/基本业绩）
- TopN 部门（按实收金额/基本业绩）
- TopN 门店（按实收金额/基本业绩）

**包厢开台 TopN**：
- TopN 包厢（按实收金额/开台次数）
- TopN 包厢类型（按实收金额/开台次数）
- TopN 时段（按实收金额/开台次数）

**酒水销售 TopN**：
- TopN 商品（按销售金额/利润）
- TopN 商品类别（按销售金额/利润）
- TopN 商品（按利润率）

#### 3.3.2 TopN 实现方案

**方案一：SQL LIMIT 子句**
```sql
SELECT ... 
FROM ...
GROUP BY ...
ORDER BY total_actual_received DESC
LIMIT N
```

**方案二：窗口函数（MySQL 8.0+）**
```sql
SELECT *
FROM (
    SELECT ...,
           ROW_NUMBER() OVER (PARTITION BY ... ORDER BY total_actual_received DESC) AS rn
    FROM ...
) t
WHERE rn <= N
```

**方案三：物化视图 + 索引**
- 在物化视图中预计算聚合结果
- 在排序字段上创建索引
- 查询时直接使用索引排序

---

## 四、宽表与物化视图设计

### 4.1 宽表设计原则

**宽表定义**：将多个事实表和维度表的数据整合在一起，形成一张宽表，便于查询和分析。

**设计原则**：
1. **维度冗余**：在宽表中冗余维度字段（如门店名称、员工姓名、包厢名称等），避免频繁 JOIN
2. **指标预计算**：预计算常用指标（如实收金额、利润率等），提升查询性能
3. **时间分区**：宽表按 `business_date` 分区，与事实表保持一致
4. **索引优化**：在常用查询字段上创建索引

### 4.2 日级聚合宽表设计

#### 4.2.1 预订汇总日级聚合宽表（agg_daily_booking_summary）

**表结构设计**：

| 字段名 | 数据类型 | 说明 |
|--------|---------|------|
| id | BIGINT UNSIGNED | 主键 |
| business_date | DATE | 营业日（分区键） |
| store_id | INT UNSIGNED | 门店ID |
| store_name | VARCHAR(100) | 门店名称（冗余） |
| employee_id | INT UNSIGNED | 员工ID |
| employee_name | VARCHAR(50) | 员工姓名（冗余） |
| department | VARCHAR(50) | 部门（冗余） |
| total_booking_count | INTEGER | 订台数合计 |
| total_sales_amount | DECIMAL(12,2) | 销售金额合计 |
| total_actual_received | DECIMAL(12,2) | 实收金额合计 |
| total_base_performance | DECIMAL(12,2) | 基本业绩合计 |
| total_discount_amount | DECIMAL(12,2) | 折扣金额合计 |
| total_gift_amount | DECIMAL(12,2) | 赠送金额合计 |
| total_free_amount | DECIMAL(12,2) | 免单金额合计 |
| total_credit_amount | DECIMAL(12,2) | 挂账金额合计 |
| total_income_payments | DECIMAL(12,2) | 收入类支付方式合计 |
| total_cost_equity_payments | DECIMAL(12,2) | 成本/权益类支付方式合计 |
| discount_rate | DECIMAL(8,2) | 折扣率（%） |
| gift_rate | DECIMAL(8,2) | 赠送率（%） |
| actual_received_rate | DECIMAL(8,2) | 实收率（%） |
| created_at | TIMESTAMP | 创建时间 |
| updated_at | TIMESTAMP | 更新时间 |

**分区策略**：
- 按 `business_date` RANGE 分区，按月分区

**索引设计**：
- 主键索引：`id`
- 普通索引：`business_date`, `store_id`, `employee_id`, `department`
- 复合索引：`(store_id, business_date)`, `(employee_id, business_date)`, `(business_date, store_id, employee_id)`

#### 4.2.2 包厢开台日级聚合宽表（agg_daily_room_analysis）

**表结构设计**：

| 字段名 | 数据类型 | 说明 |
|--------|---------|------|
| id | BIGINT UNSIGNED | 主键 |
| business_date | DATE | 营业日（分区键） |
| store_id | INT UNSIGNED | 门店ID |
| store_name | VARCHAR(100) | 门店名称（冗余） |
| room_id | INT UNSIGNED | 包厢ID |
| room_name | VARCHAR(50) | 包厢名称（冗余） |
| room_type | VARCHAR(50) | 包厢类型（冗余） |
| area_name | VARCHAR(50) | 区域名称（冗余） |
| total_order_count | INTEGER | 开台单数合计 |
| total_bill_total | DECIMAL(12,2) | 账单合计金额合计 |
| total_actual_received | DECIMAL(12,2) | 实收金额合计 |
| total_base_performance | DECIMAL(12,2) | 基本业绩合计 |
| total_duration_minutes | INTEGER | 消费时长合计（分钟） |
| avg_duration_minutes | DECIMAL(8,2) | 平均消费时长（分钟） |
| total_room_discount | DECIMAL(12,2) | 房费折扣金额合计 |
| total_beverage_discount | DECIMAL(12,2) | 酒水折扣金额合计 |
| total_income_payments | DECIMAL(12,2) | 收入类支付方式合计 |
| total_cost_equity_payments | DECIMAL(12,2) | 成本/权益类支付方式合计 |
| avg_bill_amount | DECIMAL(12,2) | 平均账单金额 |
| avg_actual_received | DECIMAL(12,2) | 平均实收金额 |
| created_at | TIMESTAMP | 创建时间 |
| updated_at | TIMESTAMP | 更新时间 |

**分区策略**：
- 按 `business_date` RANGE 分区，按月分区

**索引设计**：
- 主键索引：`id`
- 普通索引：`business_date`, `store_id`, `room_id`, `room_type`, `area_name`
- 复合索引：`(store_id, business_date)`, `(room_id, business_date)`, `(business_date, store_id, room_id)`

#### 4.2.3 酒水销售日级聚合宽表（agg_daily_beverage_sales）

**表结构设计**：

| 字段名 | 数据类型 | 说明 |
|--------|---------|------|
| id | BIGINT UNSIGNED | 主键 |
| business_date | DATE | 营业日（分区键） |
| store_id | INT UNSIGNED | 门店ID |
| store_name | VARCHAR(100) | 门店名称（冗余） |
| product_id | INT UNSIGNED | 商品ID |
| beverage_name | VARCHAR(100) | 商品名称（冗余） |
| category_name | VARCHAR(50) | 类别名称（冗余） |
| unit | VARCHAR(20) | 单位（冗余） |
| area | VARCHAR(50) | 区域（冗余） |
| total_sales_qty | INTEGER | 销售数量合计 |
| total_sales_amount | DECIMAL(12,2) | 销售金额合计（折后） |
| total_cost_total | DECIMAL(12,2) | 成本小计合计 |
| total_profit | DECIMAL(12,2) | 利润合计 |
| total_gift_qty | INTEGER | 赠送数量合计 |
| total_gift_amount | DECIMAL(12,2) | 赠送金额合计 |
| avg_profit_rate | DECIMAL(8,2) | 平均利润率（%） |
| sales_amount_per_qty | DECIMAL(12,2) | 平均单价 |
| gift_rate | DECIMAL(8,2) | 赠送率（%） |
| created_at | TIMESTAMP | 创建时间 |
| updated_at | TIMESTAMP | 更新时间 |

**分区策略**：
- 按 `business_date` RANGE 分区，按月分区

**索引设计**：
- 主键索引：`id`
- 普通索引：`business_date`, `store_id`, `product_id`, `category_name`
- 复合索引：`(store_id, business_date)`, `(product_id, business_date)`, `(category_name, business_date)`

### 4.3 物化视图设计（MySQL 8.0+）

#### 4.3.1 物化视图 vs 普通视图

**物化视图优势**：
- 预计算聚合结果，查询性能好
- 支持索引，进一步提升查询速度
- 可定期刷新，保持数据最新

**普通视图优势**：
- 实时查询，数据始终最新
- 无需维护刷新逻辑
- 适合数据量小的场景

**选择策略**：
- **MySQL 8.0+**：优先使用物化视图，定期刷新（如每小时或每天）
- **MySQL 5.7**：使用普通视图 + 定期刷新汇总表（宽表）的方案

#### 4.3.2 物化视图刷新策略

**刷新时机**：
- **增量刷新**：每次数据导入后，刷新相关日期的物化视图
- **定时刷新**：每天凌晨刷新前一天的物化视图
- **手动刷新**：支持手动触发刷新

**刷新范围**：
- 按 `business_date` 范围刷新，只刷新有数据变更的日期范围
- 支持全量刷新（重建物化视图）

**刷新性能优化**：
- 使用 `REFRESH MATERIALIZED VIEW CONCURRENTLY`（如果支持）避免锁表
- 在低峰期执行刷新操作
- 分批刷新，避免一次性刷新大量数据

### 4.4 普通视图设计（MySQL 5.7）

#### 4.4.1 视图设计原则

**设计原则**：
- 视图作为查询接口，不存储数据
- 复杂聚合逻辑封装在视图中，简化查询
- 视图可以嵌套，构建多层视图

#### 4.4.2 视图实现方案

**方案一：直接查询事实表**
- 优点：数据实时，无需维护
- 缺点：查询性能可能较慢，需要频繁 JOIN

**方案二：视图 + 汇总表（宽表）**
- 优点：查询性能好，数据预计算
- 缺点：需要维护汇总表刷新逻辑
- **推荐方案**：使用宽表（`agg_*` 表）存储预计算结果，视图作为查询接口

---

## 五、聚合 SQL 设计

### 5.1 日级聚合 SQL

#### 5.1.1 预订汇总日级聚合 SQL

**按门店聚合**：
```sql
SELECT 
    f.business_date,
    f.store_id,
    s.store_name,
    COUNT(*) AS total_records,
    SUM(f.booking_count) AS total_booking_count,
    SUM(f.sales_amount) AS total_sales_amount,
    SUM(f.actual_received) AS total_actual_received,
    SUM(f.base_performance) AS total_base_performance,
    SUM(f.discount_amount) AS total_discount_amount,
    SUM(f.gift_amount) AS total_gift_amount,
    SUM(f.free_amount) AS total_free_amount,
    SUM(f.credit_amount) AS total_credit_amount,
    -- 收入类支付方式合计
    SUM(f.payment_wechat + f.payment_alipay + f.payment_cash + 
        f.payment_pos_card + f.payment_waiter + f.payment_fubei + 
        f.payment_groupon + f.payment_douyin + f.payment_pos + 
        f.payment_gaode) AS total_income_payments,
    -- 成本/权益类支付方式合计
    SUM(f.payment_member + f.payment_employee_credit + 
        f.payment_manager_sign + f.payment_performance_commission + 
        f.payment_marketing_commission + f.payment_expired_wine + 
        f.payment_entertainment + f.payment_member_disabled) AS total_cost_equity_payments,
    -- 计算指标
    CASE 
        WHEN SUM(f.sales_amount) > 0 
        THEN SUM(f.discount_amount) / SUM(f.sales_amount) * 100 
        ELSE 0 
    END AS discount_rate,
    CASE 
        WHEN SUM(f.sales_amount) > 0 
        THEN SUM(f.gift_amount) / SUM(f.sales_amount) * 100 
        ELSE 0 
    END AS gift_rate,
    CASE 
        WHEN SUM(f.sales_amount) > 0 
        THEN SUM(f.actual_received) / SUM(f.sales_amount) * 100 
        ELSE 0 
    END AS actual_received_rate
FROM fact_booking_summary f
INNER JOIN dim_store s ON f.store_id = s.id
WHERE f.business_date BETWEEN :start_date AND :end_date
GROUP BY f.business_date, f.store_id, s.store_name
ORDER BY f.business_date DESC, f.store_id;
```

**按员工聚合**：
```sql
SELECT 
    f.business_date,
    f.store_id,
    s.store_name,
    f.employee_id,
    e.employee_name,
    f.department,
    COUNT(*) AS total_records,
    SUM(f.booking_count) AS total_booking_count,
    SUM(f.sales_amount) AS total_sales_amount,
    SUM(f.actual_received) AS total_actual_received,
    SUM(f.base_performance) AS total_base_performance,
    -- ... 其他指标
FROM fact_booking_summary f
INNER JOIN dim_store s ON f.store_id = s.id
LEFT JOIN dim_employee e ON f.employee_id = e.id
WHERE f.business_date BETWEEN :start_date AND :end_date
GROUP BY f.business_date, f.store_id, s.store_name, f.employee_id, e.employee_name, f.department
ORDER BY f.business_date DESC, total_actual_received DESC;
```

#### 5.1.2 包厢开台日级聚合 SQL

**按门店聚合**：
```sql
SELECT 
    f.business_date,
    f.store_id,
    s.store_name,
    COUNT(DISTINCT f.order_no) AS total_order_count,
    SUM(f.bill_total) AS total_bill_total,
    SUM(f.actual_received) AS total_actual_received,
    SUM(f.base_performance) AS total_base_performance,
    SUM(f.duration_minutes) AS total_duration_minutes,
    AVG(f.duration_minutes) AS avg_duration_minutes,
    SUM(f.room_discount) AS total_room_discount,
    SUM(f.beverage_discount) AS total_beverage_discount,
    -- 收入类支付方式合计
    SUM(f.payment_wechat + f.payment_alipay + f.payment_cash + 
        f.payment_bank_card + f.payment_waiter + f.payment_fubei + 
        f.payment_meituan + f.payment_douyin + f.payment_scan + 
        f.payment_gaode) AS total_income_payments,
    -- 成本/权益类支付方式合计
    SUM(f.payment_member + f.payment_employee_credit + 
        f.payment_manager_sign + f.payment_performance_commission + 
        f.payment_marketing_commission + f.payment_expired_wine + 
        f.payment_entertainment + f.payment_member_disabled) AS total_cost_equity_payments,
    -- 计算指标
    CASE 
        WHEN COUNT(DISTINCT f.order_no) > 0 
        THEN SUM(f.bill_total) / COUNT(DISTINCT f.order_no) 
        ELSE 0 
    END AS avg_bill_amount,
    CASE 
        WHEN COUNT(DISTINCT f.order_no) > 0 
        THEN SUM(f.actual_received) / COUNT(DISTINCT f.order_no) 
        ELSE 0 
    END AS avg_actual_received
FROM fact_room_analysis f
INNER JOIN dim_store s ON f.store_id = s.id
WHERE f.business_date BETWEEN :start_date AND :end_date
GROUP BY f.business_date, f.store_id, s.store_name
ORDER BY f.business_date DESC, f.store_id;
```

**按包厢聚合**：
```sql
SELECT 
    f.business_date,
    f.store_id,
    s.store_name,
    f.room_id,
    r.room_name,
    r.room_type,
    r.area_name,
    COUNT(DISTINCT f.order_no) AS total_order_count,
    SUM(f.bill_total) AS total_bill_total,
    SUM(f.actual_received) AS total_actual_received,
    -- ... 其他指标
FROM fact_room_analysis f
INNER JOIN dim_store s ON f.store_id = s.id
LEFT JOIN dim_room r ON f.room_id = r.id
WHERE f.business_date BETWEEN :start_date AND :end_date
GROUP BY f.business_date, f.store_id, s.store_name, f.room_id, r.room_name, r.room_type, r.area_name
ORDER BY f.business_date DESC, total_actual_received DESC;
```

#### 5.1.3 酒水销售日级聚合 SQL

**按门店聚合**：
```sql
SELECT 
    f.business_date,
    f.store_id,
    s.store_name,
    SUM(f.sales_qty_total) AS total_sales_qty,
    SUM(f.sales_amount_total) AS total_sales_amount,
    SUM(f.cost_total) AS total_cost_total,
    SUM(f.profit) AS total_profit,
    SUM(f.gift_qty_total) AS total_gift_qty,
    SUM(f.gift_amount_total) AS total_gift_amount,
    -- 计算指标
    CASE 
        WHEN SUM(f.cost_total) > 0 
        THEN SUM(f.profit) / SUM(f.cost_total) * 100 
        ELSE 0 
    END AS avg_profit_rate,
    CASE 
        WHEN SUM(f.sales_qty_total) > 0 
        THEN SUM(f.sales_amount_total) / SUM(f.sales_qty_total) 
        ELSE 0 
    END AS sales_amount_per_qty,
    CASE 
        WHEN (SUM(f.sales_qty_total) + SUM(f.gift_qty_total)) > 0 
        THEN SUM(f.gift_qty_total) / (SUM(f.sales_qty_total) + SUM(f.gift_qty_total)) * 100 
        ELSE 0 
    END AS gift_rate
FROM fact_beverage_sales f
INNER JOIN dim_store s ON f.store_id = s.id
WHERE f.business_date BETWEEN :start_date AND :end_date
GROUP BY f.business_date, f.store_id, s.store_name
ORDER BY f.business_date DESC, f.store_id;
```

**按商品聚合**：
```sql
SELECT 
    f.business_date,
    f.store_id,
    s.store_name,
    f.product_id,
    p.product_name,
    p.category_name,
    p.unit,
    SUM(f.sales_qty_total) AS total_sales_qty,
    SUM(f.sales_amount_total) AS total_sales_amount,
    SUM(f.cost_total) AS total_cost_total,
    SUM(f.profit) AS total_profit,
    -- ... 其他指标
FROM fact_beverage_sales f
INNER JOIN dim_store s ON f.store_id = s.id
LEFT JOIN dim_product p ON f.product_id = p.id
WHERE f.business_date BETWEEN :start_date AND :end_date
GROUP BY f.business_date, f.store_id, s.store_name, f.product_id, p.product_name, p.category_name, p.unit
ORDER BY f.business_date DESC, total_sales_amount DESC;
```

### 5.2 周级/月级聚合 SQL

#### 5.2.1 周级聚合 SQL

**使用时间维度表关联**：
```sql
SELECT 
    d.year,
    d.week,
    f.store_id,
    s.store_name,
    SUM(f.actual_received) AS total_actual_received,
    SUM(f.base_performance) AS total_base_performance,
    -- ... 其他指标
FROM fact_booking_summary f
INNER JOIN dim_store s ON f.store_id = s.id
INNER JOIN dim_date d ON f.business_date = d.date
WHERE d.date BETWEEN :start_date AND :end_date
GROUP BY d.year, d.week, f.store_id, s.store_name
ORDER BY d.year DESC, d.week DESC, f.store_id;
```

#### 5.2.2 月级聚合 SQL

**使用时间维度表关联**：
```sql
SELECT 
    d.year,
    d.month,
    f.store_id,
    s.store_name,
    SUM(f.actual_received) AS total_actual_received,
    SUM(f.base_performance) AS total_base_performance,
    -- ... 其他指标
FROM fact_booking_summary f
INNER JOIN dim_store s ON f.store_id = s.id
INNER JOIN dim_date d ON f.business_date = d.date
WHERE d.date BETWEEN :start_date AND :end_date
GROUP BY d.year, d.month, f.store_id, s.store_name
ORDER BY d.year DESC, d.month DESC, f.store_id;
```

### 5.3 TopN 查询 SQL

#### 5.3.1 TopN 员工查询

```sql
SELECT 
    f.business_date,
    f.store_id,
    s.store_name,
    f.employee_id,
    e.employee_name,
    f.department,
    SUM(f.actual_received) AS total_actual_received,
    SUM(f.base_performance) AS total_base_performance
FROM fact_booking_summary f
INNER JOIN dim_store s ON f.store_id = s.id
LEFT JOIN dim_employee e ON f.employee_id = e.id
WHERE f.business_date BETWEEN :start_date AND :end_date
GROUP BY f.business_date, f.store_id, s.store_name, f.employee_id, e.employee_name, f.department
ORDER BY total_actual_received DESC
LIMIT :top_n;
```

#### 5.3.2 TopN 商品查询

```sql
SELECT 
    f.business_date,
    f.store_id,
    s.store_name,
    f.product_id,
    p.product_name,
    p.category_name,
    SUM(f.sales_amount_total) AS total_sales_amount,
    SUM(f.profit) AS total_profit,
    CASE 
        WHEN SUM(f.cost_total) > 0 
        THEN SUM(f.profit) / SUM(f.cost_total) * 100 
        ELSE 0 
    END AS profit_rate
FROM fact_beverage_sales f
INNER JOIN dim_store s ON f.store_id = s.id
LEFT JOIN dim_product p ON f.product_id = p.id
WHERE f.business_date BETWEEN :start_date AND :end_date
GROUP BY f.business_date, f.store_id, s.store_name, f.product_id, p.product_name, p.category_name
ORDER BY total_sales_amount DESC
LIMIT :top_n;
```

---

## 六、校验报告生成

### 6.1 校验报告内容

#### 6.1.1 平衡校验报告

**预订汇总平衡校验**：
- **校验公式1**：实收金额 = 销售金额 - 免单 - 挂账 - 折扣 - 抹零 - 调整
- **校验公式2**：实收金额 = 收入类支付方式合计
- **差异计算**：差异 = |公式1结果 - 公式2结果|
- **告警阈值**：差异 > 1元（可配置）

**包厢开台平衡校验**：
- **校验公式1**：实收金额 = 账单合计 - 抹零 - 调整 - 挂账 - 免单 - 房费折扣 - 酒水折扣 - 权益类支付方式合计
- **校验公式2**：实收金额 = 收入类支付方式合计
- **差异计算**：差异 = |公式1结果 - 公式2结果|
- **告警阈值**：差异 > 1元（可配置）

**酒水销售平衡校验**：
- **校验公式1**：利润 = 销售金额小计 - 成本小计
- **校验公式2**：成本小计 = 成本_销售 + 成本_赠送
- **差异计算**：差异 = |公式1结果 - 实际利润字段|
- **告警阈值**：差异 > 0.01元（可配置）

#### 6.1.2 异常检测报告

**金额异常**：
- 实收金额为负值
- 销售金额为负值（除调整金额外）
- 成本为负值
- 利润为负值（需关注，但不一定异常）

**时间异常**：
- 开房时间晚于关房时间
- 关房时间晚于清洁时间
- 营业日不在合理范围内（如未来日期）

**数据完整性异常**：
- 必填字段缺失
- 支付方式合计与实收金额差异过大
- 会员支付与会员本金+赠送不一致

#### 6.1.3 会员支付去重校验

**校验规则**：
- 会员支付 = 会员本金 + 会员赠送（理论上应该相等）
- 差异 = |会员支付 - (会员本金 + 会员赠送)|
- 告警阈值：差异 > 0.01元（可配置）

**处理策略**：
- 优先使用会员本金 + 会员赠送的拆分值
- 若会员支付存在且与拆分值不一致，记录告警
- 实收计算时，会员本金和会员赠送均不计入实收（均属于权益类）

### 6.2 校验报告生成流程

#### 6.2.1 数据导入时校验

**流程**：
1. 数据清洗完成后，逐行进行校验
2. 记录校验结果到 `raw_rows.validation_errors` 字段（JSON格式）
3. 统计校验通过率和失败率
4. 生成批次级校验报告，记录到 `meta_file_batch.validation_report` 字段

**校验报告结构**（JSON格式）：
```json
{
    "batch_id": 123,
    "table_type": "booking_summary",
    "total_rows": 100,
    "success_rows": 95,
    "failed_rows": 5,
    "validation_summary": {
        "balance_check": {
            "total_checked": 100,
            "passed": 95,
            "failed": 5,
            "total_diff_amount": 12.50
        },
        "anomaly_check": {
            "negative_amount": 2,
            "time_cross": 1,
            "missing_required": 2
        },
        "member_payment_check": {
            "total_checked": 50,
            "passed": 48,
            "failed": 2,
            "total_diff_amount": 5.20
        }
    },
    "error_details": [
        {
            "row_number": 10,
            "error_type": "balance_check",
            "error_message": "实收金额与支付方式合计不一致，差异：2.50元",
            "expected": 1000.00,
            "actual": 1002.50
        }
    ],
    "generated_at": "2025-12-03 10:00:00"
}
```

#### 6.2.2 聚合时校验

**流程**：
1. 聚合计算完成后，对聚合结果进行校验
2. 对比不同计算路径的结果（如扣减法 vs 加总法）
3. 生成聚合级校验报告

**校验内容**：
- 日级聚合结果与明细数据汇总的一致性
- 周级/月级聚合结果与日级聚合汇总的一致性
- 不同维度聚合结果的交叉校验

### 6.3 校验报告查询接口

#### 6.3.1 批次校验报告查询

**接口设计**：
- **路径**：`/api/v1/batches/{batch_id}/validation-report`
- **方法**：GET
- **返回**：JSON格式的校验报告

#### 6.3.2 异常明细查询

**接口设计**：
- **路径**：`/api/v1/batches/{batch_id}/validation-errors`
- **方法**：GET
- **参数**：
  - `error_type`：错误类型（可选）
  - `page`：页码
  - `page_size`：每页数量
- **返回**：分页的异常明细列表

---

## 七、实施步骤与方法

### 7.1 第一阶段：口径函数定义与配置化

#### 7.1.1 创建支付方式配置表

**步骤**：
1. 在 `dim_payment_method` 维度表中初始化支付方式数据
2. 设置 `is_income` 和 `is_cost_equity` 字段，标识支付方式分类
3. 在 `meta_field_mapping` 表中，为支付方式字段设置 `is_income_payment` 和 `is_cost_equity` 标识

#### 7.1.2 实现口径计算函数

**步骤**：
1. 创建 Python 模块 `calculations/kpi_calculator.py`
2. 实现 `calculate_actual_received()` 函数
3. 实现 `calculate_performance()` 函数
4. 实现 `calculate_profit()` 函数
5. 编写单元测试，验证函数正确性

#### 7.1.3 配置化支付方式列表

**步骤**：
1. 从数据库读取支付方式配置（`dim_payment_method` 表）
2. 构建收入类支付方式列表和成本/权益类支付方式列表
3. 支持通过配置表动态调整，无需修改代码

### 7.2 第二阶段：日级聚合 SQL 与宽表设计

#### 7.2.1 设计宽表结构

**步骤**：
1. 根据聚合指标需求，设计 `agg_daily_booking_summary` 表结构
2. 根据聚合指标需求，设计 `agg_daily_room_analysis` 表结构
3. 根据聚合指标需求，设计 `agg_daily_beverage_sales` 表结构
4. 使用 Alembic 创建迁移脚本，创建宽表

#### 7.2.2 实现日级聚合 SQL

**步骤**：
1. 编写预订汇总日级聚合 SQL（按门店、按员工）
2. 编写包厢开台日级聚合 SQL（按门店、按包厢）
3. 编写酒水销售日级聚合 SQL（按门店、按商品）
4. 测试 SQL 性能，优化索引

#### 7.2.3 实现宽表刷新逻辑

**步骤**：
1. 创建 Python 模块 `aggregations/daily_aggregator.py`
2. 实现宽表刷新函数，执行聚合 SQL 并写入宽表
3. 支持增量刷新（按日期范围）和全量刷新
4. 实现幂等性（使用 `INSERT ... ON DUPLICATE KEY UPDATE`）

### 7.3 第三阶段：周级/月级聚合与 TopN

#### 7.3.1 实现周级/月级聚合

**步骤**：
1. 编写周级聚合 SQL（关联 `dim_date` 维度表）
2. 编写月级聚合 SQL（关联 `dim_date` 维度表）
3. 创建周级/月级聚合宽表（可选，或使用视图）
4. 实现聚合刷新逻辑

#### 7.3.2 实现 TopN 查询

**步骤**：
1. 编写 TopN 查询 SQL（使用 `LIMIT` 或窗口函数）
2. 创建 Python 模块 `queries/topn_query.py`
3. 实现 TopN 查询函数，支持不同维度和排序字段
4. 测试 TopN 查询性能

### 7.4 第四阶段：物化视图或视图实现

#### 7.4.1 MySQL 8.0+ 物化视图方案

**步骤**：
1. 创建物化视图 SQL（基于宽表或事实表）
2. 实现物化视图刷新逻辑（定时刷新或增量刷新）
3. 测试物化视图查询性能
4. 监控物化视图刷新时间

#### 7.4.2 MySQL 5.7 视图+宽表方案

**步骤**：
1. 创建普通视图（基于宽表）
2. 实现宽表定期刷新逻辑（使用定时任务）
3. 测试视图查询性能
4. 监控宽表刷新时间

### 7.5 第五阶段：校验报告生成

#### 7.5.1 实现数据导入时校验

**步骤**：
1. 创建 Python 模块 `validations/balance_validator.py`
2. 实现平衡校验函数（实收金额校验）
3. 实现异常检测函数（金额异常、时间异常等）
4. 实现会员支付去重校验函数
5. 集成到数据导入流程中

#### 7.5.2 实现聚合时校验

**步骤**：
1. 创建 Python 模块 `validations/aggregation_validator.py`
2. 实现聚合结果校验函数（对比不同计算路径）
3. 实现聚合一致性校验函数（日级 vs 周级/月级）
4. 集成到聚合刷新流程中

#### 7.5.3 实现校验报告查询接口

**步骤**：
1. 创建 FastAPI 路由 `/api/v1/batches/{batch_id}/validation-report`
2. 实现校验报告查询逻辑
3. 创建 FastAPI 路由 `/api/v1/batches/{batch_id}/validation-errors`
4. 实现异常明细查询逻辑（支持分页和过滤）

### 7.6 第六阶段：性能优化与监控

#### 7.6.1 性能优化

**步骤**：
1. 分析慢查询日志，识别性能瓶颈
2. 优化 SQL 查询（添加索引、优化 JOIN）
3. 优化聚合刷新逻辑（批量处理、并行处理）
4. 测试优化后的性能

#### 7.6.2 监控与告警

**步骤**：
1. 监控聚合刷新时间
2. 监控查询响应时间
3. 监控校验报告异常率
4. 设置告警阈值（如刷新时间超过10分钟、异常率超过5%）

---

## 八、测试策略

### 8.1 单元测试

#### 8.1.1 口径计算函数测试

**测试用例**：
1. 测试实收金额计算（扣减法 vs 加总法）
2. 测试业绩计算
3. 测试毛利计算
4. 测试边界情况（如金额为0、缺失值处理）

#### 8.1.2 聚合函数测试

**测试用例**：
1. 测试日级聚合 SQL（按门店、按员工、按包厢、按商品）
2. 测试周级/月级聚合 SQL
3. 测试 TopN 查询 SQL
4. 测试聚合结果准确性（与明细数据对比）

### 8.2 集成测试

#### 8.2.1 端到端聚合测试

**测试流程**：
1. 导入样例文件到事实表
2. 执行聚合刷新，生成宽表数据
3. 查询聚合结果，验证准确性
4. 对比不同计算路径的结果（如扣减法 vs 加总法）

#### 8.2.2 校验报告测试

**测试流程**：
1. 导入包含异常数据的样例文件
2. 执行校验逻辑，生成校验报告
3. 验证校验报告内容准确性
4. 验证异常明细查询功能

### 8.3 性能测试

#### 8.3.1 聚合性能测试

**测试场景**：
1. 单日单店数据聚合（小数据量）
2. 单月单店数据聚合（中等数据量）
3. 单月多店数据聚合（大数据量）
4. 全量数据聚合（最大数据量）

**性能指标**：
- 聚合刷新时间（目标：单日单店 < 1分钟）
- 查询响应时间（目标：单日查询 < 1秒）
- 资源占用（CPU、内存）

#### 8.3.2 并发测试

**测试场景**：
1. 并发查询测试（多个用户同时查询）
2. 并发聚合刷新测试（多个门店同时刷新）
3. 查询与刷新并发测试

---

## 九、维护与优化

### 9.1 日常维护

#### 9.1.1 聚合刷新监控

**监控内容**：
- 聚合刷新执行时间
- 聚合刷新成功率
- 聚合数据量增长趋势

**维护任务**：
- 定期检查聚合刷新日志
- 识别并处理刷新失败的情况
- 优化刷新性能（如调整批量大小）

#### 9.1.2 索引维护

**维护任务**：
- 定期分析索引使用情况
- 识别未使用的索引并删除
- 根据查询模式调整索引策略

### 9.2 性能优化

#### 9.2.1 SQL 优化

**优化方法**：
- 使用 `EXPLAIN` 分析查询计划
- 优化 JOIN 顺序和条件
- 使用分区裁剪（WHERE 条件包含分区键）
- 避免全表扫描

#### 9.2.2 聚合优化

**优化方法**：
- 增量聚合（只刷新变更的数据）
- 并行聚合（多线程/多进程处理）
- 批量处理（减少数据库交互次数）

### 9.3 扩展性考虑

#### 9.3.1 数据量增长

**应对策略**：
- 分区策略调整（如从按月分区改为按周分区）
- 归档历史数据（保留最近12-24个月数据）
- 考虑使用分布式数据库（如 TiDB）

#### 9.3.2 查询复杂度增长

**应对策略**：
- 使用物化视图预计算复杂查询
- 使用缓存（如 Redis）缓存热点查询结果
- 考虑使用 OLAP 数据库（如 ClickHouse）

---

## 十、总结

### 10.1 核心要点

1. **口径标准化**：通过配置化方式管理支付方式分类，确保实收、业绩、毛利口径一致
2. **聚合策略**：使用宽表或物化视图预计算聚合结果，提升查询性能
3. **校验机制**：多层次校验（导入时校验、聚合时校验），确保数据准确性
4. **性能优化**：分区、索引、增量刷新等策略，保证系统性能

### 10.2 后续工作

1. **实施开发**：按照实施步骤，逐步实现聚合与口径计算功能
2. **测试验证**：完成单元测试、集成测试、性能测试
3. **对账验证**：与财务手工结果对账，确保口径一致
4. **性能调优**：根据实际使用情况，持续优化性能

---

## 附录

### A. 参考文档

- 《具体需求.md》：业务需求说明
- 《字段映射.md》：字段映射规范
- 《入库模型.md》：数据库入库模型设计
- 《详细业务分析实现.md》：技术实施方案

### B. 版本历史

- **v1.0**（2025-12-03）：初始版本，完成聚合与口径计算设计文档

---

**文档结束**

