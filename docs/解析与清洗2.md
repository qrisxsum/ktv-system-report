# 解析与清洗流水线实施文档 (Lite版)

## 文档说明

本文档基于《具体需求.md》《字段映射.md》和《简化.md》，制定 KTV 报表系统的**简化版**数据解析与清洗规范。

**核心理念**：利用 Pandas 强大的内存处理能力，合并“读取、清洗、映射、校验”步骤。**特别强调对多级表头的扁平化处理和动态列的 JSON 归集**。

**版本号**: v2.1 (Lite)  
**生成日期**: 2025-12-09  
**技术栈**: Python 3.9+ / Pandas 2.0+

---

## 一、总体流程架构

```mermaid
graph LR
    A[上传文件] --> B{文件识别}
    B -->|csv/xls/xlsx| C[Pandas 读取 (Parser)]
    C -->|多级表头合并| D[表头扁平化 (Flattener)]
    D -->|列名映射/JSON归集| E[列名映射 (Mapper)]
    E -->|类型转换/填充0| F[数据清洗 (Cleaner)]
    F -->|平衡校验/逻辑检查| G[业务校验 (Validator)]
    G -->|校验通过| H[批量入库 (Importer)]
```

---

## 二、详细实施步骤

### 步骤 1：读取与表头处理 (Parser & Flattener)

**目标**：正确读取文件，并将 Excel 中常见的**多级表头（Merged Cells）**转换为单行标准表头。

**实施细节**：

1.  **定位标题行**:
    -   遍历前 10 行，寻找包含核心关键字（如`"实收金额"`, `"开台单号"`）的行。
    -   假设找到第 `N` 行是主标题行，通常 `N+1` 行是子标题（如 "支付方式" 下面的 "微信", "支付宝"）。

2.  **多级表头合并 (Flattening)**:
    -   如果检测到多级表头（即 Pandas 读取为 MultiIndex），或者 `N` 和 `N+1` 行都是表头部分：
    -   **合并规则**: `Parent_Child`。
        -   示例: `Line1="支付方式", Line2="微信"` -> `NewCol="支付方式_微信"`
        -   示例: `Line1="实收金额", Line2=NaN` -> `NewCol="实收金额"`
    -   **代码逻辑**:
        ```python
        # 伪代码
        df.columns = [f"{c[0]}_{c[1]}" if "Unnamed" not in c[1] else c[0] 
                      for c in df.columns]
        ```

### 步骤 2：字段映射与动态列 (Mapper)

**目标**：将中文列名转换为数据库字段名，并将未定义的支付方式归集到 JSON。

**实施细节**：

1.  **加载映射配置**:
    -   `MAPPING = {'实收金额': 'actual_amount', '支付方式_微信': 'pay_wechat', ...}`
    -   `KNOWN_PAYMENTS = ['pay_wechat', 'pay_alipay', 'pay_cash', ...]` (数据库中存在的列)

2.  **执行映射**:
    -   遍历 DataFrame 的列名。
    -   如果在 `MAPPING` 中，重命名为对应 DB 字段。
    -   如果列名包含 "支付方式" 但不在 `MAPPING` 中（如 "支付方式_数字人民币"），标记为 **Extra Payment**。

3.  **JSON 归集 (Extra Payments)**:
    -   创建新列 `extra_payments`。
    -   将所有标记为 **Extra Payment** 的列，按行聚合成 Dictionary，转为 JSON 字符串。
    -   示例: `{'pay_digital_rmb': 100, 'pay_coupon': 50}`。
    -   删除原始的 Extra Payment 列，保持 DataFrame 干净。

### 步骤 3：清洗与类型转换 (Cleaner)

**目标**：确保数值和日期格式正确。

**实施细节**：

1.  **数值清洗**:
    -   去除 `¥`, `,` 等符号。
    -   `fillna(0)`：金额和数量字段空值填 0。
2.  **日期清洗**:
    -   `biz_date`: 转换为 `YYYY-MM-DD`。
    -   `open_time`: 转换为 `YYYY-MM-DD HH:MM:SS`。

### 步骤 4：业务规则校验 (Validator)

**目标**：拦截脏数据。

**核心校验**:
1.  **平衡校验**: `实收金额 ≈ Σ(收入类支付) + Σ(JSON中的收入项)`.
2.  **非空校验**: `store_name`, `biz_date` 不能为空。

### 步骤 5：入库 (Importer)

**目标**：写入 MySQL。

**实施细节**:
1.  **自动维度**: 提取 `store_name` -> 查询/创建 `dim_store` -> 替换为 `store_id`。
2.  **覆盖写入**: Delete where `batch_id` = current -> Insert new rows.

---

## 三、异常处理

| 场景 | 处理方式 |
|---|---|
| **多级表头错位** | 尝试向前/向后搜索一行，重新合并表头。 |
| **未知支付方式** | 自动归入 `extra_payments` JSON 字段，不报错，但在日志中警告。 |
| **金额解析失败** | 记录错误行号，跳过该行或标记为 Error 状态。 |

---

## 四、开发检查清单

- [ ] **Flattener**: 能正确合并 "支付方式" + "微信" 这种上下两行的表头。
- [ ] **Mapper**: 能识别 `MAPPING` 中没有的新支付列，并将其放入 `extra_payments`。
- [ ] **Jsonizer**: 确保 `extra_payments` 生成的是合法的 JSON 字符串。
- [ ] **Importer**: 确保 JSON 字段能正确写入 MySQL 的 JSON 类型列。
